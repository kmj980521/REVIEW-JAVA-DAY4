# REVIEW-JAVA-DAY4
자바 복습하기 4일차

ArrayList(객체 배열) 클래스 사용하기

1. import java.util.ArrayList; 해주기

2.ArrayList 선언은 ArrayList<자료형> 변수 =new ArrayList();

3.변수.add(new 자료형(...)); 를 통해 요소 값 추가 // 생성자 호출

4.변수.size()는 요소의 수

5.변수.get(i)은 i번째 요소의 데이터 값을 얻음.

향상된 for문 
```java
for(Book lang:library)
		{
			lang.showinfo();
		}
```

상위 클래스로 형 변환이 된 하위클래스는 재정의된 메소드(가상 메소드)를 호출한다.

하위 클래스에서 재정의 된 메소드(@Override 애노테이션을 사용)는 오버라이드를 했다.

변수가 사용하는 메모리(힙)와 **메소드가 사용하는 메모리는 다르다**

클래스의 메소드 명령 집합은 **메소드 영역(코드 영역)에 위치** 해서 메소드를 호출하면 메소드 영역의 주소를 참조하여 명령이 실행.

가상메소드의 경우에는 **가상 메소드 테이블**이 따로 만들어진다. 각 메소드 이름과 실제 메모리 주소가 짝을 이루고 있음. 어떤 메소드가 호출되면 이 테이블에서 주소 값을 찾아서 해당 메소드의 명령을 수행

ex) 상위 클래스 a ( 메소드1, 메소드2가 존재) a클래스의 확장인 클래스 b (a의 메소드1을 재정의한 메소드, 재정의되지 않은 메소드2, 추가한 메소드3)
        하위 클래스에서 재정의된 메소드는 하위클래스의 메소드 영역을 참조.

재정의되지 않은 메소드는 메소드 주소가 상위클래스와 하위클래스 모두 같으며 상위클래스의 메소드를 호출.

하위클래스를 선언을 하고, 상위 클래스로 형변환을 하고 나서 함수를 호출하면 **가상 메소드 방식(생성된 인스턴스의 메소드 호출)에 의해서 하위클래스의 메소드가 실행된다 **(단 상위클래스에서 하위클래스로의 형변환은 불가하다)
